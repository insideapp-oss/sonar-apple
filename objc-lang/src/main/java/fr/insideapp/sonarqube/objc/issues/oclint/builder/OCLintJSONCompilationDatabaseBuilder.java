/*
 * SonarQube Apple Plugin - Enables analysis of Swift and Objective-C projects into SonarQube.
 * Copyright Â© 2022 inside|app (contact@insideapp.fr)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package fr.insideapp.sonarqube.objc.issues.oclint.builder;

import fr.insideapp.sonarqube.apple.commons.ExtensionFileFilter;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.RegExUtils;
import org.sonar.api.scanner.ScannerSide;
import org.sonar.api.utils.log.Logger;
import org.sonar.api.utils.log.Loggers;

import javax.annotation.Nonnull;
import java.io.File;
import java.io.FileFilter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Iterator;
import java.util.regex.Pattern;

@ScannerSide
public final class OCLintJSONCompilationDatabaseBuilder implements OCLintJSONCompilationDatabaseBuildable {

    private static final Pattern CLEAN_PATTERN = Pattern.compile("(\"-index-store-path.*DataStore\", |\"-index-unit-output-path.*\\.o\", )");

    private static final Logger LOGGER = Loggers.get(OCLintJSONCompilationDatabaseBuilder.class);

    private final FileFilter jsonFileFilter;

    public OCLintJSONCompilationDatabaseBuilder() {
        jsonFileFilter = new ExtensionFileFilter("json");
    }

    public String build(@Nonnull File jsonCompilationDatabaseFolder) {
        // Retrieve the JSON Database fragments
        File[] jsonFiles = jsonCompilationDatabaseFolder.listFiles(jsonFileFilter);
        // Making sure we got something
        if (jsonFiles == null) { jsonFiles = new File[]{}; }

        Iterator<File> jsonFilesIterator = Arrays.asList(jsonFiles).iterator();
        final StringBuilder compileCommandsBuilder = new StringBuilder();

        // Beginning the JSON Database
        compileCommandsBuilder.append("[");

        // For each JSON Database fragment
        while (jsonFilesIterator.hasNext()) {
            File jsonFile = jsonFilesIterator.next();
            try {
                // Getting the content
                String json = FileUtils.readFileToString(jsonFile, StandardCharsets.UTF_8);
                // Cleaning the JSON Database
                json = RegExUtils.removeAll(json, CLEAN_PATTERN);

                /* For the last one, we remove the trailing comma
                because fragments generated by clang have a comma before EOF
                and we want a valid JSON in the end
                 */
                if (!jsonFilesIterator.hasNext()) {
                    json = RegExUtils.removeFirst(json, ",$");
                }
                compileCommandsBuilder.append(json);
            } catch (Exception exception) {
                LOGGER.error("An exception occurred when reading {}. Run in debug for more information", jsonFile.getAbsolutePath());
                LOGGER.debug("Exception: {}", exception);
            }
        }

        // Ending the JSON Database
        compileCommandsBuilder.append("]");

        return compileCommandsBuilder.toString();
    }

}
